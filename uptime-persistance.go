package main

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "os"
)

const (
  k_CACHE_API_RECORDS = "./api_records.json"
)

/** File formulate

{
  "version": 1,
  "endpoints": {
    "http://etcetc:3003": {
      "last-fetch": 123123123,
      "fetches": [
          {
            "result-status": 200,
            "result-len":1231231,
            "result-roundtrip":1231231
          }
        ]
    }
  }
}

*/

// up for debate reuse this in api_touch so as to prevent degrading transforms
type HttpAPIResult struct {
  ResultEndpoint     string `json:"ResultEndpoint"`
  ResultStatusCode      int `json:"ResultStatusCode"`
  ResultLen             int `json:"ResultLen"`
  ResultTimePerformed int64 `json:"ResultTimePerformed"`
  ResultRoundtrip     int64 `json:"ResultRoundtrip"`
}

type HttpServiceDocument struct {
  LastFetch           int64 `json:"LastFetch"`
  LastEndpoint       string `json:"LastEndpoint"`
  Fetches  *[]HttpAPIResult `json:"Fetches"`
}

type AutoGenerated struct {
	Version                                     int `json:"Version"`
	Endpoints        map[string]HttpServiceDocument `json:"Endpoints"`
  EndpointsRefList                       []string `json:"EndpointsRefList"`
}

type CACHE struct {
  cached_results AutoGenerated
}

func loadRecords() AutoGenerated {
  raw, err := ioutil.ReadFile(k_CACHE_API_RECORDS)
  if err != nil {
    fmt.Println(err.Error())
    os.Exit(1)
  } else {
    // populate with default data here
  }

  var c AutoGenerated
  json.Unmarshal(raw, &c)

  return c
}

// pass by value for better thread safety
func commitRecords(records AutoGenerated) {
  records_json, err := json.Marshal(records)
  fmt.Println("[CACHE] Fail to json: " + err.Error())
  records_byte_array := []byte(records_json)
  err = ioutil.WriteFile(k_CACHE_API_RECORDS, records_byte_array, 0)
  fmt.Println("[CACHE] persistence write error: " + err.Error())
}

func recordAPIResult(result APITestResult) {
  // type APITestResult struct {
  //   endpoint string
  //   time_elapsed time.Duration
  //   time_performed time.Duration
  //   body_len int
  //   code int
  // }
  api_result := HttpAPIResult{ResultEndpoint: result.endpoint,
                              ResultStatusCode: result.code,
                              ResultLen: result.body_len,
                              ResultTimePerformed: 0,
                              ResultRoundtrip: result.time_elapsed.Nanoseconds()}
  service_document := HttpServiceDocument{}
  if result, exist := cache.cached_results.Endpoints[result.endpoint]; exist {
    service_document = result
  }

  service_document.LastFetch = result.time_performed.UnixNano()
  service_document.LastEndpoint = result.endpoint
  new_fetches := make([]HttpAPIResult, len(*service_document.Fetches)+1) // swaggy append
  new_fetches[:len(new_fetches)-1] = api_result
  service_document.Fetches = &new_fetches
  cache.cached_results.Endpoints[service_document.LastEndpoint] = service_document
  commitRecords(cache.cached_results)
}

func beginPolling() {
  // ticker := time.NewTicker(200 * time.Millisecond)
	// go func() {
	// 	for _ = range ticker.C {
  //
	// 		server.BroadcastTo(namespace_notification_root_domain, "avatar-datagram", finalString)
	// 		datagramQueue = []string{}
	// 	}
  // }()
}
